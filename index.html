<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Spectrogram (zoomable frequency band)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; padding: 16px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: #0b0f14; color: #e6edf3;
    }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; }
    .panel {
      background: #0f1621; border: 1px solid #1f2a3a;
      border-radius: 12px; padding: 12px;
    }
    canvas {
      width: 100%; height: 420px; display: block;
      background: #05070a; border-radius: 12px; border: 1px solid #1f2a3a;
    }
    label { display: grid; gap: 6px; font-size: 12px; color: #b7c3d1; }
    input[type="range"] { width: 280px; }
    input[type="number"] {
      width: 110px; padding: 6px 8px; border-radius: 8px;
      border: 1px solid #273448; background: #0b0f14; color: #e6edf3;
    }
    button {
      padding: 8px 12px; border-radius: 10px;
      border: 1px solid #2a3a53; background: #121b28; color: #e6edf3;
      cursor: pointer;
    }
    button:hover { background: #162236; }
    .hint { font-size: 12px; color: #b7c3d1; }
    .kvs { display: flex; gap: 14px; flex-wrap: wrap; font-size: 12px; color: #b7c3d1; }
    .kvs b { color: #e6edf3; }
  </style>
</head>
<body>
  <div class="row">
    <div class="panel">
      <div class="row">
        <button id="btnStart">Start mic</button>
        <button id="btnStop" disabled>Stop</button>
        <button id="btnClear">Clear</button>
      </div>
      <div class="hint" style="margin-top:8px;">
        Frequency zoom: set bottom/top. Time scrolls left→right; newest at right.
      </div>
      <div class="kvs" style="margin-top:8px;">
        <div>SR: <b id="sr">-</b></div>
        <div>FFT: <b id="fft">-</b></div>
        <div>Hop: <b id="hop">-</b></div>
        <div>Range: <b id="rangeLabel">-</b></div>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <label>
          Bottom Hz
          <div class="row">
            <input id="minHz" type="number" min="0" step="1" value="0">
            <input id="minHzRange" type="range" min="0" max="24000" value="0">
          </div>
        </label>

        <label>
          Top Hz
          <div class="row">
            <input id="maxHz" type="number" min="1" step="1" value="8000">
            <input id="maxHzRange" type="range" min="1" max="24000" value="8000">
          </div>
        </label>

        <label>
          Gain (dB lift)
          <div class="row">
            <input id="gain" type="number" step="1" value="0">
            <input id="gainRange" type="range" min="-40" max="40" value="0">
          </div>
        </label>

        <label>
          Dynamic range (dB)
          <div class="row">
            <input id="dyn" type="number" min="20" max="120" step="1" value="80">
            <input id="dynRange" type="range" min="20" max="120" value="80">
          </div>
        </label>

        <label>
          Speed (px/column)
          <div class="row">
            <input id="speed" type="number" min="1" max="8" step="1" value="1">
            <input id="speedRange" type="range" min="1" max="8" value="1">
          </div>
        </label>
      </div>
    </div>
  </div>

  <div style="margin-top:12px;">
    <canvas id="spec" width="1400" height="420"></canvas>
  </div>

  <script>
    // --- Utilities ---
    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    // Turbo-like colormap (approx), input t in [0,1] -> [r,g,b]
    // Uses a small LUT interpolation for speed.
    const TURBO_LUT = (function(){
      // 256-sample LUT of Turbo (values approximated from public domain sources).
      // To keep this file short, we generate it via a polynomial approximation.
      function turbo(t){
        // Polynomial approximation of Turbo (Anton Mikhailov / Google).
        const r = 34.61 + t*(1172.33 + t*(-10793.56 + t*(33300.12 + t*(-38394.49 + t*14825.05))));
        const g = 23.31 + t*(557.33 + t*(1225.33 + t*(-3574.96 + t*(2073.03 + t* -311.73))));
        const b = 27.2 + t*(3211.1 + t*(-15327.97 + t*(27814.0 + t*(-22569.18 + t*6838.66))));
        return [
          clamp(Math.round(r), 0, 255),
          clamp(Math.round(g), 0, 255),
          clamp(Math.round(b), 0, 255),
        ];
      }
      const lut = new Array(256);
      for (let i=0;i<256;i++){
        lut[i] = turbo(i/255);
      }
      return lut;
    })();

    function turboColorByte(v){ // v in [0,255]
      return TURBO_LUT[v|0];
    }

    // --- UI wiring ---
    const canvas = document.getElementById('spec');
    const ctx = canvas.getContext('2d', { alpha: false });

    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const btnClear = document.getElementById('btnClear');

    const minHzN = document.getElementById('minHz');
    const maxHzN = document.getElementById('maxHz');
    const minHzR = document.getElementById('minHzRange');
    const maxHzR = document.getElementById('maxHzRange');

    const gainN = document.getElementById('gain');
    const gainR = document.getElementById('gainRange');

    const dynN = document.getElementById('dyn');
    const dynR = document.getElementById('dynRange');

    const speedN = document.getElementById('speed');
    const speedR = document.getElementById('speedRange');

    const srEl = document.getElementById('sr');
    const fftEl = document.getElementById('fft');
    const hopEl = document.getElementById('hop');
    const rangeLabel = document.getElementById('rangeLabel');

    function linkNumberAndRange(numEl, rangeEl, onChange){
      const syncFromNum = () => { rangeEl.value = numEl.value; onChange?.(); };
      const syncFromRange = () => { numEl.value = rangeEl.value; onChange?.(); };
      numEl.addEventListener('input', syncFromNum);
      rangeEl.addEventListener('input', syncFromRange);
    }

    // --- Audio / spectrogram state ---
    let audioCtx = null;
    let analyser = null;
    let mediaStream = null;
    let rafId = null;

    // FFT settings
    const FFT_SIZE = 4096; // adjust for resolution vs CPU
    const SMOOTHING = 0.0;
    // We take snapshots at animation frame rate; the scroll speed controls visible time scale.

    const mag = new Float32Array(FFT_SIZE/2);

    // Offscreen image buffer for fast scroll
    const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
    // Start with black
    for (let i=0;i<img.data.length;i+=4){ img.data[i+3]=255; } // opaque

    function clearCanvas(){
      for (let i=0;i<img.data.length;i+=4){
        img.data[i]=0; img.data[i+1]=0; img.data[i+2]=0; img.data[i+3]=255;
      }
      ctx.putImageData(img,0,0);
    }

    function updateRangeLimits(sampleRate){
      const nyq = Math.floor(sampleRate/2);
      minHzR.max = String(nyq);
      maxHzR.max = String(nyq);
      minHzN.max = String(nyq);
      maxHzN.max = String(nyq);

      // clamp values to nyquist
      const minv = clamp(parseInt(minHzN.value||"0",10), 0, nyq);
      const maxv = clamp(parseInt(maxHzN.value||String(nyq),10), 1, nyq);
      minHzN.value = String(minv);
      maxHzN.value = String(Math.max(maxv, minv+1));
      minHzR.value = minHzN.value;
      maxHzR.value = maxHzN.value;
      rangeLabel.textContent = `${minHzN.value}–${maxHzN.value} Hz`;
    }

    function setupUIBindings(){
      linkNumberAndRange(minHzN, minHzR, () => {
        const minv = parseInt(minHzN.value||"0",10);
        const maxv = parseInt(maxHzN.value||"1",10);
        if (minv >= maxv) { maxHzN.value = String(minv+1); maxHzR.value = maxHzN.value; }
        rangeLabel.textContent = `${minHzN.value}–${maxHzN.value} Hz`;
      });
      linkNumberAndRange(maxHzN, maxHzR, () => {
        const minv = parseInt(minHzN.value||"0",10);
        const maxv = parseInt(maxHzN.value||"1",10);
        if (maxv <= minv) { minHzN.value = String(maxv-1); minHzR.value = minHzN.value; }
        rangeLabel.textContent = `${minHzN.value}–${maxHzN.value} Hz`;
      });

      linkNumberAndRange(gainN, gainR);
      linkNumberAndRange(dynN, dynR);
      linkNumberAndRange(speedN, speedR);
    }

    setupUIBindings();

    function binToHz(bin, sampleRate){
      return bin * sampleRate / FFT_SIZE;
    }

    function hzToBin(hz, sampleRate){
      return Math.round(hz * FFT_SIZE / sampleRate);
    }

    // Convert linear magnitude to dBFS-ish (relative); analyser.getFloatFrequencyData gives dB already,
    // but we compute from time-domain for consistent behavior across browsers.
    // We'll instead use analyser.getFloatFrequencyData, which returns dB values.
    const db = new Float32Array(FFT_SIZE/2);

    function drawColumn(){
      if (!analyser || !audioCtx) return;

      analyser.getFloatFrequencyData(db); // db values typically around [-140, 0]
      const sampleRate = audioCtx.sampleRate;

      const minHz = clamp(parseInt(minHzN.value||"0",10), 0, sampleRate/2);
      const maxHz = clamp(parseInt(maxHzN.value||String(sampleRate/2),10), 1, sampleRate/2);
      const gainDb = parseFloat(gainN.value||"0");
      const dyn = clamp(parseFloat(dynN.value||"80"), 20, 140);

      const minBin = clamp(hzToBin(minHz, sampleRate), 0, db.length-1);
      const maxBin = clamp(hzToBin(maxHz, sampleRate), 0, db.length-1);
      const lo = Math.min(minBin, maxBin);
      const hi = Math.max(minBin, maxBin);

      const H = canvas.height;
      const W = canvas.width;

      // scroll left by N pixels (speed)
      const sp = clamp(parseInt(speedN.value||"1",10), 1, 32);

      // shift image data left by sp columns
      // Do it row by row for cache friendliness
      const data = img.data;
      const rowStride = W * 4;
      const shiftBytes = sp * 4;

      for (let y=0;y<H;y++){
        const rowStart = y*rowStride;
        // copy [shiftBytes..rowStride) -> [0..rowStride-shiftBytes)
        data.copyWithin(rowStart, rowStart + shiftBytes, rowStart + rowStride);
        // clear rightmost sp pixels
        const tailStart = rowStart + (W - sp) * 4;
        for (let x=tailStart; x<rowStart+rowStride; x+=4){
          data[x]=0; data[x+1]=0; data[x+2]=0; data[x+3]=255;
        }
      }

      // draw new column(s) at right edge (sp pixels wide)
      // Map bins [lo..hi] to vertical pixels [H-1..0] (low at bottom).
      // For each y, pick corresponding bin.
      const colX0 = W - sp;
      for (let y=0;y<H;y++){
        const t = 1 - (y/(H-1));         // 0 bottom -> 1 top
        const bin = Math.round(lo + t*(hi-lo));
        const vDb = db[clamp(bin, 0, db.length-1)] + gainDb;

        // Normalize: treat 0 dB as max, and -dyn dB as min.
        // Many browsers report min around -100 to -140.
        const norm = clamp((vDb - (0 - dyn)) / dyn, 0, 1);
        const c = turboColorByte(Math.round(norm*255));

        for (let sx=0;sx<sp;sx++){
          const px = colX0 + sx;
          const idx = (y*W + px) * 4;
          data[idx]   = c[0];
          data[idx+1] = c[1];
          data[idx+2] = c[2];
          data[idx+3] = 255;
        }
      }

      ctx.putImageData(img, 0, 0);
    }

    function loop(){
      drawColumn();
      rafId = requestAnimationFrame(loop);
    }

    async function start(){
      if (audioCtx) return;

      mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        }
      });

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const src = audioCtx.createMediaStreamSource(mediaStream);

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = FFT_SIZE;
      analyser.smoothingTimeConstant = SMOOTHING;
      analyser.minDecibels = -140;
      analyser.maxDecibels = 0;

      src.connect(analyser);

      srEl.textContent = `${audioCtx.sampleRate} Hz`;
      fftEl.textContent = `${FFT_SIZE}`;
      // "Hop" isn't fixed here; we're sampling per animation frame. Provide a rough figure.
      hopEl.textContent = `~${Math.round(1000/60)} ms/col @60fps (×speed)`;

      updateRangeLimits(audioCtx.sampleRate);

      btnStart.disabled = true;
      btnStop.disabled = false;

      loop();
    }

    function stop(){
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      if (mediaStream){
        for (const t of mediaStream.getTracks()) t.stop();
        mediaStream = null;
      }
      if (audioCtx){
        audioCtx.close();
        audioCtx = null;
      }
      analyser = null;

      btnStart.disabled = false;
      btnStop.disabled = true;

      srEl.textContent = '-';
      fftEl.textContent = '-';
      hopEl.textContent = '-';
    }

    btnStart.addEventListener('click', () => start().catch(err => {
      console.error(err);
      alert('Could not start microphone: ' + err.message);
    }));
    btnStop.addEventListener('click', stop);
    btnClear.addEventListener('click', clearCanvas);

    // initial labels
    rangeLabel.textContent = `${minHzN.value}–${maxHzN.value} Hz`;
    clearCanvas();
  </script>
</body>
</html>
