<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Spectrogram (fixed overlay + dB top/bottom)</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; padding:14px;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      background:#0b0f14; color:#e6edf3;
      -webkit-user-select:none; user-select:none;
      overscroll-behavior: none;
    }
    .row{ display:flex; gap:14px; flex-wrap:wrap; align-items:flex-start; }
    .panel{ background:#0f1621; border:1px solid #1f2a3a; border-radius:12px; padding:12px; }
    label{ display:grid; gap:6px; font-size:12px; color:#b7c3d1; }
    input[type="range"]{ width:260px; }
    input[type="number"], select{
      width:120px; padding:6px 8px; border-radius:8px;
      border:1px solid #273448; background:#0b0f14; color:#e6edf3;
    }
    button{
      padding:8px 12px; border-radius:10px;
      border:1px solid #2a3a53; background:#121b28; color:#e6edf3; cursor:pointer;
    }
    button:hover{ background:#162236; }
    .kvs{ display:flex; gap:14px; flex-wrap:wrap; font-size:12px; color:#b7c3d1; }
    .kvs b{ color:#e6edf3; }
    .sep{ height:1px; background:#1f2a3a; margin:10px 0; }
    .hint{ font-size:12px; color:#b7c3d1; line-height:1.35; }
    #status{ font-size:12px; color:#b7c3d1; margin-top:8px; white-space:pre-wrap; }
    #status b{ color:#e6edf3; }

    .plots{ display:flex; gap:14px; flex-wrap:wrap; align-items:flex-start; margin-top:12px; }
    .plotA{ flex: 1 1 980px; }
    .plotB{ flex: 1 1 420px; max-width:520px; }
    @media (max-width: 900px){ .plotB{ max-width:none; width:min(100%, 1400px);} }

    .stack{ position:relative; width:min(100%, 1600px); }

    /* IMPORTANT: background only on the spectrogram canvas, NOT on the overlay */
    #spec{
      display:block; width:100%;
      height: min(70vh, 680px);        /* make it big, especially on phones */
      border-radius:12px; border:1px solid #1f2a3a;
      background:#05070a;
    }
    #overlay{
      position:absolute; left:0; top:0;
      display:block;
      width:100%;
      height: min(70vh, 680px);
      border-radius:12px;
      /* transparent by default; do NOT set background */
      touch-action:none;
      -webkit-touch-callout:none;
    }

    #spectrum{
      display:block; width:100%;
      height: min(70vh, 680px);
      border-radius:12px; border:1px solid #1f2a3a;
      background:#05070a;
    }
  </style>
</head>
<body>

<div class="row">
  <div class="panel">
    <div class="row" style="align-items:center;">
      <button id="btnStart">Start mic</button>
      <button id="btnStop" disabled>Stop</button>
      <button id="btnClear">Clear</button>

      <label style="margin-left:8px;">
        Scale
        <select id="scaleSel">
          <option value="linear" selected>Linear Hz</option>
          <option value="log">Log Hz</option>
        </select>
      </label>

      <label>
        Notes
        <select id="notesSel">
          <option value="off" selected>Off</option>
          <option value="on">On</option>
        </select>
      </label>

      <label>
        Auto dB
        <select id="autoDbSel">
          <option value="on" selected>On</option>
          <option value="off">Off</option>
        </select>
      </label>

      <label>
        Debug overlay
        <select id="dbgOverlaySel">
          <option value="off" selected>Off</option>
          <option value="tint">Tint overlay</option>
        </select>
      </label>
    </div>

    <div class="sep"></div>

    <div class="kvs">
      <div>JS: <b id="jsAlive">loading…</b></div>
      <div>SR: <b id="sr">-</b></div>
      <div>FFT: <b id="fft">-</b></div>
      <div>FPS: <b id="fps">-</b></div>
      <div>Hz: <b id="rangeLabel">-</b></div>
      <div>dB: <b id="dbLabel">-</b></div>
    </div>

    <div id="status"></div>
    <div class="hint" style="margin-top:10px;">
      Hz drag on left axis: top 25% adjusts Top Hz, bottom 25% adjusts Bottom Hz (grab-a-frequency).
    </div>
  </div>

  <div class="panel">
    <div class="row">
      <label>
        Bottom Hz
        <div class="row">
          <input id="minHz" type="number" min="0" step="1" value="0">
          <input id="minHzRange" type="range" min="0" max="24000" value="0">
        </div>
      </label>

      <label>
        Top Hz
        <div class="row">
          <input id="maxHz" type="number" min="1" step="1" value="8000">
          <input id="maxHzRange" type="range" min="1" max="24000" value="8000">
        </div>
      </label>

      <label>
        dB bottom
        <div class="row">
          <input id="dbBottom" type="number" min="-180" max="20" step="1" value="-120">
          <input id="dbBottomRange" type="range" min="-180" max="20" value="-120">
        </div>
      </label>

      <label>
        dB top
        <div class="row">
          <input id="dbTop" type="number" min="-180" max="20" step="1" value="-20">
          <input id="dbTopRange" type="range" min="-180" max="20" value="-20">
        </div>
      </label>

      <label>
        Scroll speed (px/col)
        <div class="row">
          <input id="speed" type="number" min="1" max="8" step="1" value="1">
          <input id="speedRange" type="range" min="1" max="8" value="1">
        </div>
      </label>

      <label>
        Redraw throttle (ms)
        <div class="row">
          <input id="redrawMs" type="number" min="0" max="500" step="10" value="60">
          <input id="redrawMsRange" type="range" min="0" max="500" step="10" value="60">
        </div>
      </label>
    </div>

    <div class="hint" style="margin-top:10px;">
      If spectrogram is dark: set Auto dB=Off, try dB bottom=-140, dB top=-10.
    </div>
  </div>
</div>

<div class="plots">
  <div class="panel plotA" style="padding:12px;">
    <div class="stack" id="stack">
      <!-- Use fixed internal resolution; CSS scales it up. -->
      <canvas id="spec" width="1600" height="900"></canvas>
      <canvas id="overlay" width="1600" height="900"></canvas>
    </div>
  </div>

  <div class="panel plotB" style="padding:12px;">
    <canvas id="spectrum" width="900" height="900"></canvas>
    <div class="hint" style="margin-top:8px;">Spectrum (latest frame): dB vs Hz.</div>
  </div>
</div>

<script>
(() => {
  const statusEl = document.getElementById('status');
  function logStatus(msg){ statusEl.textContent = msg; }
  window.addEventListener('error', (e) => logStatus("JS error:\n" + (e.message || e.error || e)));

  function must(id){
    const el = document.getElementById(id);
    if(!el) throw new Error("Missing element id='" + id + "'");
    return el;
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function nowMs(){ return performance.now(); }

  // Turbo LUT
  const TURBO_LUT = (() => {
    function turbo(t){
      const r = 34.61 + t*(1172.33 + t*(-10793.56 + t*(33300.12 + t*(-38394.49 + t*14825.05))));
      const g = 23.31 + t*(557.33 + t*(1225.33 + t*(-3574.96 + t*(2073.03 + t* -311.73))));
      const b = 27.2  + t*(3211.1 + t*(-15327.97 + t*(27814.0  + t*(-22569.18 + t*6838.66))));
      return [clamp(Math.round(r),0,255), clamp(Math.round(g),0,255), clamp(Math.round(b),0,255)];
    }
    const lut = new Array(256);
    for(let i=0;i<256;i++) lut[i] = turbo(i/255);
    return lut;
  })();
  function turboColorByte(v){ return TURBO_LUT[v|0]; }

  function linkNumberAndRange(numEl, rangeEl, onChange){
    const syncFromNum = () => { rangeEl.value = numEl.value; onChange?.(); };
    const syncFromRange = () => { numEl.value = rangeEl.value; onChange?.(); };
    numEl.addEventListener('input', syncFromNum);
    rangeEl.addEventListener('input', syncFromRange);
  }

  // DOM
  const jsAlive = must('jsAlive'); jsAlive.textContent = "ok";
  const spec = must('spec');
  const overlay = must('overlay');
  const spectrumCanvas = must('spectrum');

  const sctx = spec.getContext('2d', { alpha:false });
  const octx = overlay.getContext('2d'); // transparent overlay
  const pctx = spectrumCanvas.getContext('2d', { alpha:false });

  const btnStart = must('btnStart');
  const btnStop  = must('btnStop');
  const btnClear = must('btnClear');

  const minHzN = must('minHz');
  const maxHzN = must('maxHz');
  const minHzR = must('minHzRange');
  const maxHzR = must('maxHzRange');

  const dbBottomN = must('dbBottom');
  const dbTopN    = must('dbTop');
  const dbBottomR = must('dbBottomRange');
  const dbTopR    = must('dbTopRange');

  const speedN = must('speed');
  const speedR = must('speedRange');

  const redrawMsN = must('redrawMs');
  const redrawMsR = must('redrawMsRange');

  const scaleSel = must('scaleSel');
  const notesSel = must('notesSel');
  const autoDbSel = must('autoDbSel');
  const dbgOverlaySel = must('dbgOverlaySel');

  const srEl = must('sr');
  const fftEl = must('fft');
  const fpsEl = must('fps');
  const rangeLabel = must('rangeLabel');
  const dbLabel = must('dbLabel');

  // Audio
  let audioCtx = null;
  let analyser = null;
  let mediaStream = null;
  let rafId = null;

  const FFT_SIZE = 4096;
  const BINS = FFT_SIZE/2;
  const dbFrame = new Float32Array(BINS);

  // History + pixel buffer
  const W = spec.width, H = spec.height;
  const img = sctx.getImageData(0,0,W,H);
  for(let i=0;i<img.data.length;i+=4) img.data[i+3] = 255;

  let history = new Array(W);
  for(let x=0;x<W;x++) history[x] = null;

  let lastSpectrum = new Float32Array(BINS);

  // Mapping
  function hzToBin(hz, sr){ return Math.round(hz * FFT_SIZE / sr); }
  function mapYtoHz(y, minHz, maxHz, scale){
    const t = 1 - (y/(H-1)); // 0 bottom, 1 top
    if(scale === 'linear') return minHz + t*(maxHz - minHz);
    const a = Math.log(minHz), b = Math.log(maxHz);
    return Math.exp(a + t*(b - a));
  }
  function hzToY(hz, minHz, maxHz, scale){
    if(scale === 'linear'){
      const t = (hz - minHz) / (maxHz - minHz);
      return (1 - t) * (H-1);
    }
    const t = (Math.log(hz) - Math.log(minHz)) / (Math.log(maxHz) - Math.log(minHz));
    return (1 - t) * (H-1);
  }

  function enforceHzRange(){
    if(!audioCtx){
      rangeLabel.textContent = `${minHzN.value}–${maxHzN.value} Hz`;
      return;
    }
    const nyq = Math.floor(audioCtx.sampleRate/2);
    const isLog = (scaleSel.value === 'log');
    const minFloor = isLog ? 5 : 0;

    let minv = clamp(parseInt(minHzN.value||"0",10), minFloor, nyq);
    let maxv = clamp(parseInt(maxHzN.value||String(nyq),10), minFloor+1, nyq);
    if(maxv <= minv) maxv = Math.min(nyq, minv+1);

    minHzN.value = String(minv);
    maxHzN.value = String(maxv);
    minHzR.value = minHzN.value;
    maxHzR.value = maxHzN.value;
    rangeLabel.textContent = `${minHzN.value}–${maxHzN.value} Hz`;
  }

  function enforceDbRange(){
    let lo = parseFloat(dbBottomN.value||"-120");
    let hi = parseFloat(dbTopN.value||"-20");
    if(hi <= lo) hi = lo + 1;
    dbBottomN.value = String(lo);
    dbTopN.value = String(hi);
    dbBottomR.value = dbBottomN.value;
    dbTopR.value = dbTopN.value;
    dbLabel.textContent = `${lo.toFixed(0)}..${hi.toFixed(0)} dB`;
  }

  function updateRangeLimits(sr){
    const nyq = Math.floor(sr/2);
    minHzR.max = String(nyq);
    maxHzR.max = String(nyq);
    minHzN.max = String(nyq);
    maxHzN.max = String(nyq);
    enforceHzRange();
  }

  // Auto dB window (sets sliders, so you can see what it's doing)
  function percentileOfSorted(arr, p){
    const idx = clamp(Math.round((p/100)*(arr.length-1)), 0, arr.length-1);
    return arr[idx];
  }
  function estimateAutoDb(spectrumDb){
    const step = 4;
    const samples = [];
    for(let i=0;i<spectrumDb.length;i+=step) samples.push(spectrumDb[i]);
    samples.sort((a,b)=>a-b);
    const lo = percentileOfSorted(samples, 10);
    const hi = percentileOfSorted(samples, 98);
    const span = Math.max(50, hi - lo);
    return { bottom: hi - span, top: hi };
  }

  // Rendering
  function renderColumn(x, spectrumDb){
    const sr = audioCtx.sampleRate;
    const minHz = parseInt(minHzN.value||"0",10);
    const maxHz = parseInt(maxHzN.value||String(sr/2),10);
    const scale = scaleSel.value;

    let dbBottom = parseFloat(dbBottomN.value||"-120");
    let dbTop    = parseFloat(dbTopN.value||"-20");
    if(autoDbSel.value === 'on'){
      const w = estimateAutoDb(spectrumDb);
      // update UI occasionally to avoid jitter
      dbBottom = w.bottom;
      dbTop = w.top;
    }
    const denom = Math.max(1e-6, (dbTop - dbBottom));

    const d = img.data;
    for(let y=0;y<H;y++){
      const hz = mapYtoHz(y, minHz, maxHz, scale);
      const bin = clamp(hzToBin(hz, sr), 0, BINS-1);
      const vDb = spectrumDb[bin];

      const norm = clamp((vDb - dbBottom) / denom, 0, 1);
      const c = turboColorByte(Math.round(norm*255));

      const idx = (y*W + x) * 4;
      d[idx] = c[0]; d[idx+1] = c[1]; d[idx+2] = c[2]; d[idx+3] = 255;
    }
  }

  function scrollAndAppend(latestDb){
    const sp = clamp(parseInt(speedN.value||"1",10), 1, 32);
    const d = img.data;
    const rowStride = W*4;
    const shiftBytes = sp*4;

    for(let y=0;y<H;y++){
      const rowStart = y*rowStride;
      d.copyWithin(rowStart, rowStart + shiftBytes, rowStart + rowStride);
      const tailStart = rowStart + (W - sp)*4;
      for(let p=tailStart; p<rowStart+rowStride; p+=4){
        d[p]=0; d[p+1]=0; d[p+2]=0; d[p+3]=255;
      }
    }

    history.copyWithin(0, sp);
    for(let i=0;i<sp;i++){
      history[W - sp + i] = latestDb.slice();
    }

    for(let i=0;i<sp;i++){
      renderColumn(W - sp + i, latestDb);
    }

    sctx.putImageData(img, 0, 0);
  }

  let redrawTimer = null;
  let lastRedrawAt = 0;
  function scheduleFullRedraw(force=false){
    if(!audioCtx){ drawOverlay(); return; }
    const throttle = clamp(parseInt(redrawMsN.value||"60",10), 0, 2000);
    const t = nowMs();
    if(force || throttle === 0){
      fullRedraw();
      return;
    }
    if(t - lastRedrawAt >= throttle){
      fullRedraw();
      return;
    }
    if(redrawTimer) clearTimeout(redrawTimer);
    redrawTimer = setTimeout(() => { redrawTimer = null; fullRedraw(); }, throttle);
  }

  function fullRedraw(){
    if(!audioCtx) return;
    enforceHzRange();
    enforceDbRange();

    const d = img.data;
    for(let x=0;x<W;x++){
      const col = history[x];
      if(!col){
        for(let y=0;y<H;y++){
          const idx = (y*W + x)*4;
          d[idx]=0; d[idx+1]=0; d[idx+2]=0; d[idx+3]=255;
        }
      } else {
        renderColumn(x, col);
      }
    }
    sctx.putImageData(img,0,0);
    lastRedrawAt = nowMs();
    drawOverlay();
    drawSpectrumPlot();
  }

  function clearAll(){
    const d = img.data;
    for(let i=0;i<d.length;i+=4){ d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=255; }
    sctx.putImageData(img,0,0);
    for(let x=0;x<W;x++) history[x] = null;
    drawOverlay();
    drawSpectrumPlot();
  }

  // Overlay (Hz axis + optional notes + debug tint)
  function pitchClassColor(pc){
    const hue = (pc / 12) * 360;
    return `hsla(${hue}, 90%, 60%, 0.65)`;
  }
  function drawNoteLines(minHz, maxHz, scale, axisW){
    const A4 = 440;
    const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const nMin = Math.floor(69 + 12*Math.log2(minHz / A4));
    const nMax = Math.ceil (69 + 12*Math.log2(maxHz / A4));
    for(let n=nMin; n<=nMax; n++){
      const f = A4 * Math.pow(2, (n-69)/12);
      if(f < minHz || f > maxHz) continue;
      const y = hzToY(f, minHz, maxHz, scale);
      const pc = ((n % 12) + 12) % 12;

      octx.strokeStyle = pitchClassColor(pc);
      octx.lineWidth = 1;
      octx.beginPath();
      octx.moveTo(axisW, y+0.5);
      octx.lineTo(W, y+0.5);
      octx.stroke();

      octx.fillStyle = 'rgba(230,237,243,0.55)';
      octx.font = '11px system-ui';
      const name = noteNames[pc] + Math.floor((n/12)-1);
      octx.fillText(name, axisW + 6, y);
    }
  }

  function drawOverlay(){
    const w = overlay.width, h = overlay.height;
    octx.clearRect(0,0,w,h);

    const axisW = 78;
    const pad = 8;

    if(dbgOverlaySel.value === 'tint'){
      // If you ever “lose” the spectrogram, this shows whether overlay is hiding it.
      octx.fillStyle = 'rgba(255,0,255,0.08)'; // magenta tint across overlay
      octx.fillRect(0,0,w,h);
      octx.fillStyle = 'rgba(0,255,255,0.10)'; // cyan tint for axis hit-zone
      octx.fillRect(0,0,axisW,h);
    }

    // axis strip (this part is intentionally opaque-ish)
    octx.fillStyle = 'rgba(15,22,33,0.85)';
    octx.fillRect(0,0,axisW,h);

    octx.strokeStyle = 'rgba(230,237,243,0.55)';
    octx.lineWidth = 1;
    octx.beginPath();
    octx.moveTo(axisW-0.5, 0);
    octx.lineTo(axisW-0.5, h);
    octx.stroke();

    octx.fillStyle = 'rgba(230,237,243,0.85)';
    octx.font = '12px system-ui';
    octx.textBaseline = 'middle';
    octx.fillText('Hz', pad, 14);

    if(!audioCtx) return;

    const sr = audioCtx.sampleRate;
    const minHz = parseInt(minHzN.value||"0",10);
    const maxHz = parseInt(maxHzN.value||String(sr/2),10);
    const scale = scaleSel.value;

    let ticks = [];
    if(scale === 'linear'){
      const span = maxHz - minHz;
      const targetTicks = 6;
      const rawStep = span / targetTicks;
      const pow10 = Math.pow(10, Math.floor(Math.log10(rawStep)));
      const steps = [1,2,5,10].map(m => m*pow10);
      let step = steps[0];
      for(const s of steps) if(Math.abs(s-rawStep) < Math.abs(step-rawStep)) step = s;
      const start = Math.ceil(minHz/step)*step;
      for(let f=start; f<=maxHz+1e-9; f+=step) ticks.push(f);
    } else {
      const lo = Math.max(minHz, 1);
      const hi = Math.max(maxHz, lo+1);
      const d0 = Math.floor(Math.log10(lo));
      const d1 = Math.ceil(Math.log10(hi));
      const bases = [1,2,5];
      for(let d=d0; d<=d1; d++){
        const decade = Math.pow(10,d);
        for(const b of bases){
          const f = b*decade;
          if(f>=lo && f<=hi) ticks.push(f);
        }
      }
    }

    for(const f of ticks){
      const y = hzToY(f, minHz, maxHz, scale);
      if(y < 0 || y > h) continue;

      octx.strokeStyle = 'rgba(230,237,243,0.45)';
      octx.beginPath();
      octx.moveTo(axisW-10, y+0.5);
      octx.lineTo(axisW-1, y+0.5);
      octx.stroke();

      const label = (f >= 1000) ? `${(f/1000).toFixed(f<10000?1:0)}k` : `${Math.round(f)}`;
      octx.fillStyle = 'rgba(230,237,243,0.85)';
      octx.fillText(label, pad, y);
    }

    if(notesSel.value === 'on'){
      drawNoteLines(minHz, maxHz, scale, axisW);
    }
  }

  function drawSpectrumPlot(){
    const w = spectrumCanvas.width, h = spectrumCanvas.height;
    pctx.fillStyle = '#000';
    pctx.fillRect(0,0,w,h);
    if(!audioCtx) return;

    const sr = audioCtx.sampleRate;
    const minHz = parseInt(minHzN.value||"0",10);
    const maxHz = parseInt(maxHzN.value||String(sr/2),10);
    const scale = scaleSel.value;

    let dbBottom = parseFloat(dbBottomN.value||"-120");
    let dbTop    = parseFloat(dbTopN.value||"-20");
    if(autoDbSel.value === 'on'){
      const wdb = estimateAutoDb(lastSpectrum);
      dbBottom = wdb.bottom;
      dbTop = wdb.top;
    }
    const denom = Math.max(1e-6, (dbTop - dbBottom));

    pctx.strokeStyle = 'rgba(230,237,243,0.85)';
    pctx.lineWidth = 1;
    pctx.beginPath();

    for(let px=0; px<w; px++){
      const t = px/(w-1);
      let hz;
      if(scale === 'linear'){
        hz = minHz + t*(maxHz - minHz);
      } else {
        const mn = Math.max(minHz, 5);
        hz = Math.exp(Math.log(mn) + t*(Math.log(maxHz)-Math.log(mn)));
      }
      const bin = clamp(hzToBin(hz, sr), 0, BINS-1);
      const vDb = lastSpectrum[bin];

      const yn = clamp((vDb - dbBottom) / denom, 0, 1);
      const y = (1 - yn) * (h-1);

      if(px===0) pctx.moveTo(px, y);
      else pctx.lineTo(px, y);
    }
    pctx.stroke();
  }

  // Axis dragging (Hz only), grab-a-frequency model
  let drag = null;
  overlay.addEventListener('pointerdown', (e) => {
    if(!audioCtx) return;
    e.preventDefault();
    overlay.setPointerCapture(e.pointerId);

    const rect = overlay.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (overlay.width / rect.width);
    const y = (e.clientY - rect.top)  * (overlay.height / rect.height);

    const axisW = 78;
    if(x > axisW) return;

    const zone = (y > H*0.75) ? 'bottom' : (y < H*0.25) ? 'top' : 'mid';
    if(zone === 'mid') return;

    const minHz = parseInt(minHzN.value,10);
    const maxHz = parseInt(maxHzN.value,10);
    const scale = scaleSel.value;
    const f0 = mapYtoHz(y, minHz, maxHz, scale);

    drag = { pointerId: e.pointerId, zone, f0 };
  }, { passive:false });

  overlay.addEventListener('pointermove', (e) => {
    if(!drag || !audioCtx || e.pointerId !== drag.pointerId) return;
    e.preventDefault();

    const rect = overlay.getBoundingClientRect();
    const y = (e.clientY - rect.top) * (overlay.height / rect.height);

    const sr = audioCtx.sampleRate;
    const nyq = Math.floor(sr/2);
    const scale = scaleSel.value;
    const isLog = (scale === 'log');
    const minFloor = isLog ? 5 : 0;

    let minHz = parseInt(minHzN.value,10);
    let maxHz = parseInt(maxHzN.value,10);

    const t = clamp(1 - (y/(H-1)), 1e-6, 1 - 1e-6);

    if(scale === 'linear'){
      if(drag.zone === 'top'){
        const newMax = Math.round(minHz + (drag.f0 - minHz) / t);
        maxHz = clamp(newMax, minHz + 1, nyq);
      } else {
        const newMin = Math.round((drag.f0 - t*maxHz) / (1 - t));
        minHz = clamp(newMin, minFloor, maxHz - 1);
      }
    } else {
      const A = Math.log(Math.max(minHz, minFloor));
      const B = Math.log(Math.max(maxHz, minFloor+1));
      const lf0 = Math.log(Math.max(drag.f0, minFloor));

      if(drag.zone === 'top'){
        const newB = (lf0 - (1 - t)*A) / t;
        const newMax = Math.round(Math.exp(newB));
        maxHz = clamp(newMax, minHz + 1, nyq);
      } else {
        const newA = (lf0 - t*B) / (1 - t);
        const newMin = Math.round(Math.exp(newA));
        minHz = clamp(newMin, minFloor, maxHz - 1);
      }
    }

    minHzN.value = String(minHz);
    maxHzN.value = String(maxHz);
    minHzR.value = minHzN.value;
    maxHzR.value = maxHzN.value;

    enforceHzRange();
    scheduleFullRedraw();
  }, { passive:false });

  overlay.addEventListener('pointerup', (e) => { if(drag && e.pointerId === drag.pointerId) drag = null; }, { passive:false });
  overlay.addEventListener('pointercancel', (e) => { if(drag && e.pointerId === drag.pointerId) drag = null; }, { passive:false });

  // Loop + FPS
  let fpsT0 = nowMs();
  let fpsCount = 0;
  let autoDbUiCooldown = 0;

  function loop(){
    if(!analyser || !audioCtx) return;

    analyser.getFloatFrequencyData(dbFrame);
    lastSpectrum.set(dbFrame);

    // If auto dB is on, update the UI occasionally (so it doesn't jitter each frame).
    if(autoDbSel.value === 'on'){
      const t = nowMs();
      if(t > autoDbUiCooldown){
        const w = estimateAutoDb(lastSpectrum);
        dbBottomN.value = String(Math.round(w.bottom));
        dbTopN.value = String(Math.round(w.top));
        dbBottomR.value = dbBottomN.value;
        dbTopR.value = dbTopN.value;
        enforceDbRange();
        autoDbUiCooldown = t + 250;
      }
    }

    scrollAndAppend(lastSpectrum);
    drawOverlay();
    drawSpectrumPlot();

    fpsCount++;
    const t = nowMs();
    if(t - fpsT0 >= 500){
      fpsEl.textContent = ((fpsCount * 1000) / (t - fpsT0)).toFixed(1);
      fpsT0 = t; fpsCount = 0;
    }
    rafId = requestAnimationFrame(loop);
  }

  async function start(){
    if(audioCtx) return;
    logStatus("Requesting microphone permission…");

    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(mediaStream);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0.0;
    analyser.minDecibels = -140;
    analyser.maxDecibels = 0;
    src.connect(analyser);

    srEl.textContent = `${audioCtx.sampleRate} Hz`;
    fftEl.textContent = `${FFT_SIZE}`;

    updateRangeLimits(audioCtx.sampleRate);
    enforceDbRange();

    btnStart.disabled = true;
    btnStop.disabled = false;

    logStatus("Mic started.");
    scheduleFullRedraw(true);
    rafId = requestAnimationFrame(loop);
  }

  function stop(){
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;

    if(mediaStream){
      for(const t of mediaStream.getTracks()) t.stop();
      mediaStream = null;
    }
    if(audioCtx){
      audioCtx.close();
      audioCtx = null;
    }
    analyser = null;

    btnStart.disabled = false;
    btnStop.disabled = true;

    srEl.textContent = '-';
    fftEl.textContent = '-';
    fpsEl.textContent = '-';
    logStatus("Stopped.");

    drawOverlay();
    drawSpectrumPlot();
  }

  // Wire controls
  linkNumberAndRange(minHzN, minHzR, () => { enforceHzRange(); scheduleFullRedraw(); });
  linkNumberAndRange(maxHzN, maxHzR, () => { enforceHzRange(); scheduleFullRedraw(); });

  linkNumberAndRange(dbBottomN, dbBottomR, () => { enforceDbRange(); scheduleFullRedraw(); });
  linkNumberAndRange(dbTopN, dbTopR, () => { enforceDbRange(); scheduleFullRedraw(); });

  linkNumberAndRange(speedN, speedR);
  linkNumberAndRange(redrawMsN, redrawMsR);

  scaleSel.addEventListener('change', () => { enforceHzRange(); scheduleFullRedraw(true); });
  notesSel.addEventListener('change', drawOverlay);
  autoDbSel.addEventListener('change', () => {
    if(autoDbSel.value === 'off') enforceDbRange();
    scheduleFullRedraw(true);
  });
  dbgOverlaySel.addEventListener('change', drawOverlay);

  btnStart.addEventListener('click', () => start().catch(err => {
    logStatus("Mic start failed:\n" + (err && err.message ? err.message : String(err)));
  }));
  btnStop.addEventListener('click', stop);
  btnClear.addEventListener('click', () => { clearAll(); logStatus("Cleared."); });

  // Init
  enforceDbRange();
  rangeLabel.textContent = `${minHzN.value}–${maxHzN.value} Hz`;
  clearAll();
  drawOverlay();
  drawSpectrumPlot();
  logStatus("Ready.");
})();
</script>
</body>
</html>
